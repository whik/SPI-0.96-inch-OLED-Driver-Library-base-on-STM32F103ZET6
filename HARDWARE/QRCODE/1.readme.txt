注意：本二维码驱动代码是完整版，无需修改，编解码都有，并适当注释。

使用方法：找到QR_Encode.c文件，并找到在此文件中找到BOOL EncodeData(char *lpsSource)函数，
这个函数就是生成二维码的核心函数，用法也很简单，只需把你需要转换的字符作为参数传入即可。
如 EncodeData("http://www.csdn.net/")。这时二维码的转换结果，已经保存在全局变量二维数组
m_byModuleData[MAX_MODULESIZE][MAX_MODULESIZE]中，这个二维数组中保存的都是0、1比特值
（有点像单色BMP位图），0就代表二维码的空白点，1就代表二维码的黑点了。现在你需要做的就是
把这些空白点和黑点通过LCD显示屏显示出来，最终就会得到你要的二维码。

知识传播才有价值，欢迎大家奔走相告，不保留版权，随便用。

CSDN Blog:http://blog.csdn.net/qq_21475601
---泡在妞里的Feel.   11/03/2017

//////////////////////////////////////修复记录/////////////////////////////////////
（1）增加“data_type.h”文件，此文件包含必要数据类型的定义。__（12/12/2017）

///////////////////////////////////////////////////////////////////////////////////

*********************************Questions and Answers*****************************
Q：二维码生成后的尺寸怎么确定？
A: 在"QR_Encode.h"中，通过设置宏定义MAX_MODULESIZE的值，来确定你需要的二维码的尺寸，
   这个宏只是设置最大所能生成二维码的尺寸。当你转换的字符数比较少，而MAX_MODULESIZE
   的值较大时，全局数组m_byModuleData[MAX_MODULESIZE][MAX_MODULESIZE]将不会被填满。
   我们可以通过查看另一个全局变量m_nSymbleSize的值，来确定转换成的二维码尺寸。

Q: 内存消耗问题？
A：宏定义MAX_MODULESIZE的值,决定了全局数组m_byModuleData[MAX_MODULESIZE][MAX_MODULESIZE]
   的大小，假如#define MAX_MODULESIZE 37,那么（37*37）/1024 = 1.34Kb.除次之外还有很多
   全局变量和局部变量，所以对单片机来说内存消耗还是不可忽略的。
   根据很多朋友反映，表示很想在低性能的单片机（如：传统的51）上移植此套二维码驱动。
   在51上不是不能移植，是内存和ROM都太小，当然现在的增强型51已经很棒了。在这里给大家
   一个粗略的指标，至少(RAM:4K,Flash:10K)，满足这个你可以尝试移植。ARM现在都这么便宜
   性能也强，资料也很多，建议用ARM芯片吧。

Q: 二维码怎么放大？
A: 由于生成的二维码是单倍的，在直接显示时，会非常小，不利于扫码。但很遗憾，这套二维码
   驱动不支持放大。鉴于此，你可能要自己写一个放大算法。这也很简单，放大二倍就是一个点
   变四个点，三倍就是一个点变九个点......在某些显示器（如LCD12864），由于12864是以字节
   的形式写数据的，鉴于此，你需要把生成的二维码原始数据，转换成字节的形式。

************************************************************************************
